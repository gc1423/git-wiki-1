# redis 基本知识

## 一、数据模型

1. redis属于键值对（key-value）型数据库。
2. redis的key只能是字符串类型。
3. redis的value有5中数据类型： 字符串、列表、集合、有序集合、哈希

| 数据类型 | 可以存储的值 | 操作 |
| :--: | :--: | :--: |
| STRING | 字符串、整数或者浮点数 | 对整个字符串或者字符串的其中一部分执行操作\</br\> 对整数和浮点数执行自增或者自减操作 |
| LIST | 列表 | 从两端压入或者弹出元素 \</br\> 对单个或者多个元素进行修剪，\</br\> 只保留一个范围内的元素 |
| SET | 无序集合 | 添加、获取、移除单个元素\</br\> 检查一个元素是否存在于集合中\</br\> 计算交集、并集、差集\</br\> 从集合里面随机获取元素 |
| HASH | 包含键值对的无序散列表 | 添加、获取、移除单个键值对\</br\> 获取所有键值对\</br\> 检查某个键是否存在|
| ZSET | 有序集合 | 添加、获取、删除元素\</br\> 根据分值范围或者成员来获取元素\</br\> 计算一个键的排名 |

4. TODO: redis数据结构： https://bbs.huaweicloud.com/blogs/317523


### 阅读列表

1、 [Redis数据模型详解 申艳超-博客](https://www.cnblogs.com/lch-Hao/p/10928278.html)

## 基本操作

redis支持5中数据类型， 每种数据类型都有不同的基本操作集， 具体可查询文档 [redis命令快速查询](https://redis.io/commands/)

1. 字符串主要有三种基本操作， 增/改(set) 查(get) 删(del)

  
```html
> set hello world
OK
> get hello
"world"
> del hello
(integer) 1
> get hello
(nil)
```

2. 在实际使用中， redis针对字符串的提供了许多增删改查的快捷命令

    - append 将新值添加到原值的后面， 若key不存在，效果同set
    - decr 数值减一（若value不是数字或数字超范围时报错；若key不存在， value赋值为0， 然后减一）
    - decrby 除数值可以任意设定外， 与decr行为一致
    - getdel get和del的组合， 删除key， 并返回key原本对应的value值。
    - getex 获取超时时间
    
    。。。 TODO 

## I/O模型

常说redis是一个单线程数据库， 其实只是网络IO和数据读写是单线程处理的， 在redis中也是有异步线程来实现各种其他机制， 比如持久化、异步数据删除等等。

Q: 为什么redis要使用单线程来处理网络IO和数据读写？ 

A: 多线程如果设计良好的话可以大幅提高系统运行的效率， 但容易引入额外的复杂度，共享资源竞争的问题极容易导致效率提升没有预期的效果， 而且redis的单线程设计已经足够达到相当高的效率

Q: 为什么redis单线程就可以达到这么高的效率？ 

A: 主要有两个方面：
   
   1. redis是内存数据库， 数据都存在内存中， 效率本来就非常高， 而且redis的数据结构比如hash表、调表都非常高效， 因此数据操作的IO本来就不会成为瓶颈。
   2. 主要瓶颈在网络IO上， 这个部分使用了大名鼎鼎的IO多路复用模型（linux上的实现是select/epoll模型）， 单线程就足以处理大量的网络请求。
 
Q: IO多路复用模型怎样做到单线程就足以处理大量请求？ 

A: IO多路服用模型允许系统单线程运行中同时存在多个监听socket和已连接socket， 系统内核会一直监听这些socket， 如果有请求或者数据到达， 便会交给redis线程做处理。 简单理解就是： 系统帮忙维护了一个socket列表， socket上有更新时通知redis线程，形成一个事件队列， redis线程按顺序处理这些事件。

## 索引模块

TODO: https://bbs.huaweicloud.com/blogs/317523

